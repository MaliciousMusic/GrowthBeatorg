<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!--
    We limit zoom but still allow scrolling by using maximum-scale=1 and
    'user-scalable=no'. We'll also handle double-tap in JS events below.
  -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Sound Buttons (Web Audio API)</title>
  <style>
    /* --- Styles Généraux --- */
    body {
      margin: 0;
      padding: 0;
      height: 100vh;
      font-family: Arial, sans-serif;
      background-color: #000000;
       /* Ensure that if content exceeds screen size, we can scroll. */
       overflow-y: scroll;
    }

    /* --- Conteneur Principal --- */
    .main-flexbox {
      display: flex;
      flex-direction: column; /* Empile les rangées verticalement */
      height: 100vh; /* Occupe toute la hauteur de l'écran */
      box-sizing: border-box;
      background-color: #ffffff;
    }

    /* --- Rangées --- */
    .row {
      display: flex;
      flex-direction: row; /* Colonnes alignées horizontalement */
      flex: 1; /* Chaque rangée prend un espace égal */
    }

    /* --- Colonnes --- */
    .column {
      display: flex;
      flex-direction: column; /* Empile les éléments verticalement */
      flex: 1; /* Chaque colonne prend un espace égal dans la rangée */
      background-color: #ffffff;
      box-sizing: border-box;
    }

    /* --- Boutons --- */
    .button {
      flex: 1; /* Chaque bouton prend un espace égal dans sa colonne */
      border: 3px #f0f0f0;
      text-align: center;
      font-size: 1rem;
      font-weight: bold;
      color: #fff;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .button:hover {
      transform: scale(1.05); /* Agrandir légèrement au survol */
    }

    /* --- Couleurs des boutons --- */
    .blue0 { background-color: #61abf6; }
    .blue { background-color: #0066cc; }
    .blue2 { background-color: #002d5b; }
    .yellow { background-color: #ffcc00; }
    .red { background-color: #b60808; }
    .orange { background-color: #ff6600; }

    /* Greens */
    .green0 { background-color: #98eb98; } 
    .green1 { background-color: #79ff79; }
    .green2 { background-color: #52e252; }
    .green3 { background-color: #33cc33; }
    .green4 { background-color: #23a023; }
    .green5 { background-color: #146814; }
    .green6 { background-color: #075007; }
    .green7 { background-color: #003700; }
    .green8 { background-color: #002e00; } 
    .green9 { background-color: #001a00; } 

    /* Yellow-to-Brown Gradient */
    .ye0 { background-color: #ffffcc; }
    .ye1 { background-color: #ffff99; }
    .ye2 { background-color: #ffcc66; }
    .ye3 { background-color: #ff9933; }
    .ye4 { background-color: #ff6600; }
    .ye5 { background-color: #cc5200; }
    .ye6 { background-color: #993d00; }
    .ye7 { background-color: #662900; }
    .ye8 { background-color: #4d1f00; }
    .ye9 { background-color: #331400; }

    .cyan { background-color: #00cccc; }
    .pink { background-color: #ff66cc; }
    .fuschia { background-color: #990b5e; }
    .purple { background-color: #4f045e; }
    .darkgray { background-color: #454545; }
    .gray { background-color: #808080; }
    .black { background-color: #171717; }

    /* Big Button Container */
    .big-button-container {
      display: flex;
      justify-content: center; /* Center horizontally */
      align-items: center;
      gap: 10px; /* spacing between record & delete buttons */
      height: 50px; /* Adjust height as needed */
      width: 100%; /* Full width */
    }

    /* Big Button Style */
    .big-button {
      background-color: white;
      border: #0066cc;
      color: #000;
      font-family: "Arial";
      font-size: 1.2rem;
      width: 40%; /* or adjust as you prefer */
      cursor: pointer;
      transition: transform 0.2s, background-color 0.3s;
      height: 40px;
    }
    .big-button:hover {
      background-color: #f0f0f0; /* Light gray hover effect */
      transform: scale(1.05); /* Slightly enlarge on hover */
    }

    /* Sélection visuelle */
    .selected {
      filter: brightness(250%);
    }

    footer {
      height: 10vh;
      background-color: #222; /* Dark background */
      color: #fff; /* White text */
      display: flex;
      align-items: center; /* Center text vertically */
      justify-content: center; /* Center text horizontally */
      font-size: 1rem; /* Adjust font size as needed */
      text-align: center;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2); /* Optional shadow for styling */
    }

    /* ====== MODAL FOR USERNAME ====== */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex; 
      justify-content: center; 
      align-items: center;
      z-index: 999; 
    }
    .modal-window {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }
    .modal-window h2 {
      margin-top: 0;
    }
    .modal-window input {
      padding: 8px;
      font-size: 1rem;
      margin-top: 10px;
      display: block;
      width: 100%;
    }
    .modal-window button {
      margin-top: 10px;
      padding: 8px 20px;
      font-size: 1rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Modal for username -->
  <div class="modal-overlay" id="modalOverlay">
    <div class="modal-window">
      <h2>Enter Username</h2>
      <input type="text" id="usernameInput" placeholder="Username" />
      <button id="usernameSubmit">OK</button>
    </div>
  </div>

  <div class="main-flexbox">

    <!-- Première Rangée -->
    <div class="row">

      <!-- Column 1: now "hihat" -->
      <div class="column" data-sound="hihat">
        <button class="button blue2" data-frequency="1000"></button>
        <button class="button blue" data-frequency="2000"></button>
      </div>

      <!-- Column 2: now "kick" -->
      <div class="column" data-sound="kick">
        <button class="button green0" data-frequency="20"></button>
        <button class="button green1" data-frequency="40"></button>
        <button class="button green2" data-frequency="60"></button>
        <button class="button green3" data-frequency="80"></button>
        <button class="button green1" data-frequency="120"></button>
        <button class="button green2" data-frequency="140"></button>
        <button class="button green3" data-frequency="160"></button>
        <button class="button green4" data-frequency="180"></button>
        <button class="button green5" data-frequency="200"></button>
        <button class="button green6" data-frequency="220"></button>
        <button class="button green7" data-frequency="240"></button>
        <button class="button green8" data-frequency="280.00"></button>
        <button class="button green9" data-frequency="100"></button>
      </div>

      <!-- Column 3: now "distortion" -->
      <div class="column" data-sound="distortion">
        <button class="button red" data-frequency="100"></button>
        <button class="button orange" data-frequency="200"></button>
        <button class="button yellow" data-frequency="100"></button>
        <button class="button green1" data-frequency="100"></button>
        <button class="button cyan" data-frequency="300"></button>
        <button class="button pink" data-frequency="500"></button>
        <button class="button fuschia" data-frequency="600"></button>
        <button class="button purple" data-frequency="700"></button>
      </div>

      <!-- Column 4: now "bass" -->
      <div class="column" data-sound="bass">
        <button class="button red" data-frequency="100"></button>
        <button class="button orange" data-frequency="200"></button>
        <button class="button yellow" data-frequency="100"></button>
        <button class="button green1" data-frequency="100"></button>
        <button class="button cyan" data-frequency="300"></button>
        <button class="button pink" data-frequency="500"></button>
        <button class="button fuschia" data-frequency="600"></button>
        <button class="button purple" data-frequency="700"></button>
      </div>

      <!-- Column 5: now "snare" -->
      <div class="column" data-sound="snare">
        <button class="button blue0" data-frequency="123.25"></button>
        <button class="button blue" data-frequency="587.33"></button>
        <button class="button blue2" data-frequency="659.25"></button>
      </div>

      <!-- Column 6: now "choir" -->
      <div class="column" data-sound="choir">
        <button class="button ye0" data-frequency="230"></button>
        <button class="button ye1" data-frequency="260"></button>
        <button class="button ye2" data-frequency="290"></button>
        <button class="button ye3" data-frequency="320"></button>
        <button class="button ye1" data-frequency="380"></button>
        <button class="button ye2" data-frequency="410"></button>
        <button class="button ye3" data-frequency="440"></button>
        <button class="button ye4" data-frequency="470"></button>
        <button class="button ye5" data-frequency="500"></button>
        <button class="button ye6" data-frequency="530"></button>
        <button class="button ye7" data-frequency="560"></button>
        <button class="button ye8" data-frequency="590"></button>
        <button class="button ye9" data-frequency="350"></button>
      </div>

    </div>

    <div class="big-button-container">
      <button class="big-button" id="recordButton">R E C O R D</button>
      <button class="big-button" id="deleteLoopButton">DELETE LOOP</button>
    </div>

    <footer class="footer">
      <p>© 2025 GrowthBeat. All Rights Reserved.</p>
    </footer>

  </div>

  <script>
    // === Audio Context ===
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // === MASTER BUS ===
    // We'll route all sound through masterGain,
    // so we can later insert a filter or other FX for "modulation."
    const masterGain = audioCtx.createGain();
    masterGain.connect(audioCtx.destination);

    // === Simple filter effect that we can enable for "selected mode" fun
    let modulatorFilter = audioCtx.createBiquadFilter();
    modulatorFilter.type = 'lowpass';
    modulatorFilter.frequency.value = 22050; // effectively no filter if set high
    // We'll connect it only when needed
    let isFilterActive = false;

    // LFO references
    let lfoOscillators = [];

    // === Global State ===
    let isRecording = false;
    let recordedLayers = [];     // All recorded layers
    let currentLayer = [];       // Currently recording layer
    let playbackTimeouts = [];   // For loop playback timeouts
    let activeNotes = new Map(); // Track notes that start during recording
    const activeOscillators = new Map(); // For continuous press

    // For selection mode
    let selectionMode = false;
    let selectedButtons = new Set();
    let holdTimeout = null;

    // If user typed "Agent33", we allow selection mode
    let canUseSelectionMode = false; 

    // ========== 1) FUN SOUNDS =============
    //  (Same as your original custom functions)

    // Kick (808-ish)
    function play808Sound(frequency) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.type = "sine";
      osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);

      gain.gain.setValueAtTime(1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1);

      // route to masterGain
      osc.connect(gain).connect(masterGain);

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 1);
    }

    // Distortion + Spectral (Space)
    function playDistortionSpectralSpace(frequency) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const waveShaper = audioCtx.createWaveShaper();
      const filter = audioCtx.createBiquadFilter();

      osc.type = 'triangle';
      osc.frequency.value = frequency;

      waveShaper.curve = new Float32Array([1, 0.5, -0.5, 0]);
      waveShaper.oversample = '4x';

      filter.type = 'lowpass';
      filter.frequency.value = frequency * 2;
      filter.Q.value = 50;

      gain.gain.setValueAtTime(1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

      osc.connect(waveShaper).connect(filter).connect(gain).connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.5);
    }

    // Choir
    function playChoir(frequency) {
      const osc = audioCtx.createOscillator();
      const formantFilter = audioCtx.createBiquadFilter();
      const gain = audioCtx.createGain();

      osc.type = 'sine';
      osc.frequency.value = frequency;

      formantFilter.type = 'bandpass';
      formantFilter.frequency.value = 800;
      formantFilter.Q.value = 10;

      gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);

      osc.connect(formantFilter).connect(gain).connect(masterGain);
      osc.start();
      osc.stop(audioCtx.currentTime + 2);
    }

    // Synth1: Warm Pad
    function playSynth1(frequency) {
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc1.type = 'sawtooth';
      osc1.frequency.value = frequency;
      osc2.type = 'sawtooth';
      osc2.frequency.value = frequency * 1.01;

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);

      osc1.connect(gain).connect(masterGain);
      osc2.connect(gain);

      osc1.start();
      osc2.start();
      osc1.stop(audioCtx.currentTime + 2);
      osc2.stop(audioCtx.currentTime + 2);
    }

    // Synth4: Atmospheric Choir
    function playSynth4(frequency) {
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc1.type = 'sine';
      osc1.frequency.value = frequency;
      osc2.type = 'sine';
      osc2.frequency.value = frequency * 1.5;

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);

      osc1.connect(gain).connect(masterGain);
      osc2.connect(gain);

      osc1.start();
      osc2.start();
      osc1.stop(audioCtx.currentTime + 2);
      osc2.stop(audioCtx.currentTime + 2);
    }

    // Synth6: Resonant Strings
    function playSynth6(frequency) {
      const osc1 = audioCtx.createOscillator();
      const osc2 = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      const filter = audioCtx.createBiquadFilter();

      osc1.type = 'triangle';
      osc1.frequency.value = frequency;
      osc2.type = 'triangle';
      osc2.frequency.value = frequency * 0.99;

      filter.type = 'bandpass';
      filter.frequency.value = frequency;
      filter.Q.value = 12;

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);

      osc1.connect(filter).connect(gain).connect(masterGain);
      osc2.connect(filter);

      osc1.start();
      osc2.start();
      osc1.stop(audioCtx.currentTime + 2);
      osc2.stop(audioCtx.currentTime + 2);
    }

    // === Decide Which Sound to Play Based on Column
    function playColumnSoundStart(column, frequency) {
      const soundType = column.getAttribute('data-sound');
      switch (soundType) {
        case 'kick':
          play808Sound(frequency);
          break;
        case 'distortion':
          playDistortionSpectralSpace(frequency);
          break;
        case 'choir':
          playChoir(frequency);
          break;
        case 'snare':
          playSynth1(frequency);
          break;
        case 'hihat':
          playSynth4(frequency);
          break;
        case 'bass':
          playSynth6(frequency);
          break;
        default:
          playChoir(frequency);
          break;
      }
    }

    // === Scheduling Playback of Recorded Notes
    function scheduleNotePlayback(column, frequency, offset, duration) {
      const soundType = column.getAttribute('data-sound');
      // Short or one-shot sounds
      if (
        soundType === 'kick' ||
        soundType === 'distortion' ||
        soundType === 'choir' ||
        soundType === 'snare' ||
        soundType === 'hihat' ||
        soundType === 'bass'
      ) {
        const startTimeout = setTimeout(() => {
          playColumnSoundStart(column, frequency);
        }, offset);
        playbackTimeouts.push(startTimeout);
      } else {
        // Fallback: continuous oscillator approach
        const startTimeout = setTimeout(() => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();

          osc.type = 'sine';
          osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
          gain.gain.setValueAtTime(0.5, audioCtx.currentTime);

          osc.connect(gain).connect(masterGain);
          osc.start();

          const stopTimeout = setTimeout(() => {
            osc.stop();
            osc.disconnect();
          }, duration);
          playbackTimeouts.push(stopTimeout);
        }, offset);
        playbackTimeouts.push(startTimeout);
      }
    }

    // === Playback All Layers in a Loop ===
    function playRecordedLayers() {
      // Clear old timeouts
      playbackTimeouts.forEach(timeout => clearTimeout(timeout));
      playbackTimeouts = [];

      if (!recordedLayers.length) return;

      // Find max duration among all layers
      const maxDuration = Math.max(
        ...recordedLayers.flatMap(layer =>
          layer.map(entry => (entry.startTime + entry.duration) - layer[0].startTime)
        )
      );

      // Schedule each layer’s events
      recordedLayers.forEach(layer => {
        const layerStart = layer[0].startTime;
        layer.forEach(entry => {
          const offset = entry.startTime - layerStart;
          scheduleNotePlayback(
            entry.column,
            entry.frequency,
            offset,
            entry.duration
          );
        });
      });

      // Repeat
      const loopTimeout = setTimeout(playRecordedLayers, maxDuration + 500);
      playbackTimeouts.push(loopTimeout);
    }

    // === Buttons Setup ===
const buttons = document.querySelectorAll('.button');
buttons.forEach(button => {
  const column = button.closest('.column');

  // Single tap or click => either select (if in selection mode) or play sound
  function handleButtonSelection() {
    if (selectionMode) {
      // Toggle selection for selection mode
      if (!button.classList.contains('selected')) {
        button.classList.add('selected');
        selectedButtons.add(button);
      } else {
        button.classList.remove('selected');
        selectedButtons.delete(button);
      }
      updateModulatorEffects();
    } else {
      // Normal record mode => quick “one-shot” sound
      const frequency = parseFloat(button.getAttribute('data-frequency'));
      playColumnSoundStart(column, frequency);
    }
  }

  // Touchstart => possibly start continuous oscillator (if not in selection mode)
  button.addEventListener('touchstart', e => {
    // FIX #1: Only prevent default if NOT in selection mode
    if (!selectionMode) {
      e.preventDefault();

      const frequency = parseFloat(button.getAttribute('data-frequency'));
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
      osc.connect(masterGain);
      osc.start();

      // Remember this oscillator so we can stop it later
      activeOscillators.set(button, osc);

      // If we're recording, start note
      if (isRecording) {
        activeNotes.set(button, {
          column,
          frequency,
          startTime: performance.now(),
          duration: 0
        });
      }
    }
  }, { passive: false });

  // Touchend => stop continuous oscillator
  button.addEventListener('touchend', e => {
    e.preventDefault();
    const osc = activeOscillators.get(button);
    if (osc) {
      osc.stop();
      osc.disconnect();
      activeOscillators.delete(button);
    }

    // finalize note
    if (isRecording && activeNotes.has(button)) {
      const noteObj = activeNotes.get(button);
      noteObj.duration = performance.now() - noteObj.startTime;
      currentLayer.push(noteObj);
      activeNotes.delete(button);
    }
  }, { passive: false });

  // Touchcancel => stop
  button.addEventListener('touchcancel', e => {
    e.preventDefault();
    const osc = activeOscillators.get(button);
    if (osc) {
      osc.stop();
      osc.disconnect();
      activeOscillators.delete(button);
    }
    if (isRecording && activeNotes.has(button)) {
      const noteObj = activeNotes.get(button);
      noteObj.duration = performance.now() - noteObj.startTime;
      currentLayer.push(noteObj);
      activeNotes.delete(button);
    }
  }, { passive: false });

  // Desktop click => same selection logic
  button.addEventListener('click', handleButtonSelection);
});


    // === RECORD & DELETE LOOP BUTTONS ===
    const recordButton = document.getElementById('recordButton');
    const deleteLoopButton = document.getElementById('deleteLoopButton');

    function handleRecordButtonClick() {
      // If not in selection mode => handle recording logic
      if (!selectionMode) {
        if (isRecording) {
          // Stop recording
          isRecording = false;
          // End any active notes
          activeNotes.forEach((noteObj, btn) => {
            noteObj.duration = performance.now() - noteObj.startTime;
            currentLayer.push(noteObj);
          });
          activeNotes.clear();

          if (currentLayer.length) {
            recordedLayers.push(currentLayer);
          }
          currentLayer = [];

          recordButton.textContent = 'RECORD';

          // Start loop playback
          if (recordedLayers.length > 0) {
            playRecordedLayers();
          }
        } else {
          // Start recording
          isRecording = true;
          // Clear timeouts if any loop was playing
          playbackTimeouts.forEach(timeout => clearTimeout(timeout));
          playbackTimeouts = [];
          currentLayer = [];
          recordButton.textContent = 'STOP RECORDING';
        }
      } else {
        // If in selection mode, we could do something else,
        // e.g. finalize selection or apply some UI feedback.
        // For now, just do a quick visual feedback:
        recordButton.style.color = 'green';
        setTimeout(() => {
          recordButton.style.color = '';
        }, 800);
      }
    }

    // Long-press logic to toggle selection mode
    recordButton.addEventListener('mousedown', () => {
  holdTimeout = setTimeout(() => {
    // ...
    selectionMode = !selectionMode;
    recordButton.textContent = selectionMode ? 'RECORD AGAIN' : 'RECORD';

    if (!selectionMode) {
      // FIX #2: leaving selection mode => stop recording
      isRecording = false; 
      recordButton.textContent = 'RECORD';

      selectedButtons.forEach(btn => btn.classList.remove('selected'));
      selectedButtons.clear();
      updateModulatorEffects();
    }
  }, 2000);
});


    recordButton.addEventListener('touchstart', (e) => {
      e.preventDefault();
      holdTimeout = setTimeout(() => {
        if (!canUseSelectionMode) {
          alert("ERROR // The sequencer isn't available on your browser.");
          return;
        }
        selectionMode = !selectionMode;
        recordButton.textContent = selectionMode ? 'RECORD AGAIN' : 'RECORD';
        if (!selectionMode) {
          selectedButtons.forEach(btn => btn.classList.remove('selected'));
          selectedButtons.clear();
          updateModulatorEffects();
        }
      }, 2000);
    }, { passive: false });

    recordButton.addEventListener('mouseup', () => {
      clearTimeout(holdTimeout);
      handleRecordButtonClick();
    });
    recordButton.addEventListener('mouseleave', () => {
      clearTimeout(holdTimeout);
    });
    recordButton.addEventListener('touchend', (e) => {
      e.preventDefault();
      clearTimeout(holdTimeout);
      handleRecordButtonClick();
    }, { passive: false });
    recordButton.addEventListener('touchcancel', () => {
      clearTimeout(holdTimeout);
    });

    // DELETE LOOP => Clear recordedLayers, stop all playback
    deleteLoopButton.addEventListener('click', () => {
      // stop any loops
      playbackTimeouts.forEach(timeout => clearTimeout(timeout));
      playbackTimeouts = [];
      // clear data
      recordedLayers = [];
      currentLayer = [];
      // reset button text if we were in the middle of rec
      isRecording = false;
      recordButton.textContent = 'RECORD';
    });

    // === MODULATION EFFECTS WHEN IN SELECTION MODE ===
    // For demonstration: We create a lowpass filter + LFO for each selected button
    // The LFO changes the filter frequency in a range to produce interesting movement
    function updateModulatorEffects() {
      // If we are not in selection mode or no selected buttons => bypass
      if (!selectionMode || selectedButtons.size === 0) {
        // Disconnect if filter is active
        if (isFilterActive) {
          masterGain.disconnect();
          modulatorFilter.disconnect();
          masterGain.connect(audioCtx.destination);
          isFilterActive = false;
        }
        // Stop any LFOs
        lfoOscillators.forEach(osc => {
          osc.stop();
          osc.disconnect();
        });
        lfoOscillators = [];
        return;
      }

      // Otherwise, connect the filter if not already
      if (!isFilterActive) {
        masterGain.disconnect();
        masterGain.connect(modulatorFilter).connect(audioCtx.destination);
        isFilterActive = true;
      }

      // Stop old LFOs
      lfoOscillators.forEach(osc => {
        osc.stop();
        osc.disconnect();
      });
      lfoOscillators = [];

      // For each selected button => create an LFO that affects modulatorFilter.frequency
      // Summation approach: we'll vary the filter around some base by sum of LFOs
      // A simpler approach is to pick one LFO based on last button, but let's do them all:
      let baseFreq = 500; // a moderate cutoff
      let totalOffset = 0; 

      selectedButtons.forEach(btn => {
        const freqVal = parseFloat(btn.getAttribute('data-frequency')) || 100;
        // We'll interpret freqVal as the LFO's speed *or amplitude
        const lfo = audioCtx.createOscillator();
        const lfoGain = audioCtx.createGain();

        // LFO oscillator
        lfo.type = 'sine';
        lfo.frequency.value = freqVal / 50; // scale down for a more interesting speed

        // amplitude of the LFO
        lfoGain.gain.value = 200; // range of +/- 200 around base freq

        lfo.connect(lfoGain);

        // We'll connect it to modulatorFilter.frequency via setTargetAtTime
        lfoGain.connect(modulatorFilter.frequency);

        lfo.start();
        lfoOscillators.push(lfo);

        // We also sum up an offset
        totalOffset += freqVal;
      });

      // We set an initial "base" frequency to something that depends on the number of selected buttons
      const averageOffset = totalOffset / selectedButtons.size;
      modulatorFilter.frequency.value = baseFreq + averageOffset;
    }

    // === USERNAME POP-UP & LOCALSTORAGE “DB” EXAMPLE ===
    const modalOverlay = document.getElementById("modalOverlay");
    const usernameInput = document.getElementById("usernameInput");
    const usernameSubmit = document.getElementById("usernameSubmit");

    // On page load, show modal (simple example)
    // If you want to skip showing if already stored in localStorage, you can do that logic.
    window.addEventListener('load', () => {
      modalOverlay.style.display = 'flex';
    });

    usernameSubmit.addEventListener('click', () => {
      const userName = usernameInput.value.trim();
      if (!userName) return;

      // “Database” store in localStorage
      localStorage.setItem('username', userName);

      // If user typed Agent33 => unlock selection mode
      if (userName === 'Agent33') {
        canUseSelectionMode = true;
      }

      // Hide modal
      modalOverlay.style.display = 'none';
    });

    // === Double-tap Zoom Prevention (Mobile) ===
    let lastTouchEnd = 0;
    document.addEventListener(
      'touchstart',
      (event) => {
        if (event.touches.length > 1) {
          event.preventDefault();
        }
      },
      { passive: false }
    );
    document.addEventListener(
      'touchend',
      (event) => {
        const now = new Date().getTime();
        if (now - lastTouchEnd <= 300) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      },
      { passive: false }
    );

  </script>
</body>
</html>
